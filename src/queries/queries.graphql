fragment TokenContractInfo on TokenContract {
  name
  network
  description
  collectionAddress
  symbol
  chain
}

fragment FullMedia on TokenContentMedia {
  size
  url
  size
  mimeType
  mimeType
  mediaEncoding {
    large
    poster
    preview
    thumbnail
  }
}

fragment PriceSummary on PriceAtTime {
  blockNumber
  ethPrice {
    decimal
    raw
  }
  nativePrice {
    decimal
    raw
    currency {
      address
      decimals
      name
    }
  }
  usdcPrice {
    decimal
    raw
  }
}

fragment MintDetails on MintInfo {
  price {
    ...PriceSummary
  }
  originatorAddress
  toAddress
  mintContext {
    ...TransactionDetails
  }
}

fragment TransactionDetails on TransactionInfo {
  blockNumber
  blockTimestamp
  transactionHash
  logIndex
}

fragment SaleInfo on Sale {
  saleContractAddress
  transactionInfo {
    ...TransactionDetails
  }
  buyerAddress
  collectionAddress
  # saleType{ SaleEventType!}
  price {
    ...PriceSummary
  }
  sellerAddress
  tokenId
}

fragment V2AuctionMarketProperties on V2Auction {
  __typename
  firstBidTime
  highestBidder
  curator
  collectionAddress
  curatorFeePercentage
  status
  tokenId
  auctionCurrency
  duration
  estimatedExpirationTime
  auctionStatus: status
  tokenOwner
  address
  auctionId
  approved
  reservePrice {
    ...PriceSummary
  }
  highestBidPrice {
    ...PriceSummary
  }
}

fragment V3AskProperties on V3Ask {
  __typename
  buyer
  finder
  findersFeeBps
  sellerFundsRecipient
  askStatus: status
  seller
  address
  askCurrency
  collectionAddress
  askPrice {
    ...PriceSummary
  }
}

fragment MarketPropertiesFull on MarketProperties {
  # TODO: iain support v1 liquidity?
  ...V2AuctionMarketProperties
  ...V3AskProperties
}

fragment MarketInfo on Market {
  collectionAddress
  marketAddress
  marketType
  transactionInfo {
    ...TransactionDetails
  }
  price {
    ...PriceSummary
  }
  status
  networkInfo {
    chain
    network
  }
}

fragment MarketDetails on Market {
  properties {
    ...MarketPropertiesFull
  }
}

fragment TokenInfo on Token {
  tokenId
  tokenContract {
    ...TokenContractInfo
  }
  mintInfo {
    ...MintDetails
  }
  collectionAddress
  lastRefreshTime
  owner
  name
  description
  image {
    ...FullMedia
  }
  content {
    ...FullMedia
  }
}

fragment EventInfo on Event {
  transactionInfo {
    ...TransactionDetails
  }
  eventType
  collectionAddress
  tokenId
  properties {
    ... on MintEvent {
      tokenId
      collectionAddress
      originatorAddress
      toAddress
      fee {
        ...PriceSummary
      }
    }
    ... on TransferEvent {
      fromAddress
      toAddress
      collectionAddress
      tokenId
    }
    ... on V1MarketEvent {
      marketEventType: eventType
      address
      collectionAddress
      tokenId
      # todo: properties
    }
    ... on V2AuctionEvent {
      auctionEventType: eventType
      address
      auctionId
      collectionAddress
      tokenId
      # todo: properties
    }
    ... on V3AskEvent {
      v3AskEventType: eventType
      address
      collectionAddress
      tokenId
      # todo: properties
    }
  }
}

fragment TokenDetails on Token {
  metadata

  tokenUrl
  tokenUrlMimeType

  attributes {
    traitType
    value
    displayType
  }
}

fragment CollectionInfo on Collection {
  address
  description
  name
  symbol
  totalSupply
}

fragment CollectionDetails on Collection {
  attributes {
    traitType
    valueMetrics {
      count
      percent
      value
    }
  }
}

fragment PageInfoDefault on PageInfo {
  limit
  offset
}

fragment OwnerCountInfo on OwnerCount {
  owner
  count
}

query events(
  $networks: [NetworkInput!]!
  $filter: EventsQueryFilter
  $pagination: PaginationInput!
  $sort: EventSortKeySortInput!
  $where: EventsQueryInput
) {
  events(
    networks: $networks
    filter: $filter
    pagination: $pagination
    sort: $sort
    where: $where
  ) {
    hasNextPage
    pageInfo {
      limit
      offset
    }
    nodes {
      ...EventInfo
    }
  }
}

query markets(
  $networks: [NetworkInput!]!
  $filter: MarketsQueryFilter
  $pagination: PaginationInput!
  $sort: MarketSortKeySortInput!
  $where: MarketsQueryInput
  $includeFullDetails: Boolean!
) {
  markets(
    networks: $networks
    filter: $filter
    sort: $sort
    where: $where
    pagination: $pagination
  ) {
    hasNextPage
    pageInfo {
      limit
      offset
    }
    nodes {
      token {
        ...TokenInfo
        ...TokenDetails @include(if: $includeFullDetails)
      }
      market {
        ...MarketInfo
        ...MarketDetails @include(if: $includeFullDetails)
      }
    }
  }
}

query mints(
  $networks: [NetworkInput!]!
  $filter: MintsQueryFilter
  $pagination: PaginationInput!
  $sort: MintSortKeySortInput!
  $where: MintsQueryInput
  $includeFullDetails: Boolean!
) {
  mints(
    where: $where
    networks: $networks
    filter: $filter
    pagination: $pagination
    sort: $sort
  ) {
    nodes {
      mint {
        collectionAddress
        tokenId
      }
      markets(pagination: $pagination, sort: { sortKey: NONE, sortDirection: DESC }) {
        ...MarketInfo
        ...MarketDetails @include(if: $includeFullDetails)
      }
    }
  }
}

query collections(
  $networks: [NetworkInput!]!
  $where: CollectionsQueryInput!
  $pagination: PaginationInput!
  $sort: CollectionSortKeySortInput!
  $includeFullDetails: Boolean!
) {
  collections(where: $where, networks: $networks, pagination: $pagination, sort: $sort) {
    hasNextPage
    pageInfo {
      limit
      offset
    }
    nodes {
      ...CollectionInfo
      ...CollectionDetails @include(if: $includeFullDetails)
    }
  }
}

query tokens(
  $networks: [NetworkInput!]!
  $where: TokensQueryInput
  $filter: TokensQueryFilter
  $pagination: PaginationInput!
  $sort: TokenSortInput!
  $includeFullDetails: Boolean!
  $includeSalesHistory: Boolean!
) {
  tokens(
    where: $where
    networks: $networks
    pagination: $pagination
    sort: $sort
    filter: $filter
  ) {
    hasNextPage
    pageInfo {
      limit
      offset
    }
    nodes {
      marketsSummary {
        ...MarketInfo
        ...MarketDetails @include(if: $includeFullDetails)
      }
      token {
        ...TokenInfo
        ...TokenDetails @include(if: $includeFullDetails)
      }
      sales(
        pagination: { limit: 10, offset: 0 }
        sort: { sortKey: TIME, sortDirection: DESC }
      ) {
        ...SaleInfo @include(if: $includeSalesHistory)
      }
    }
  }
}

query token($network: NetworkInput!, $token: TokenInput!, $includeFullDetails: Boolean!) {
  token(network: $network, token: $token) {
    token {
      ...TokenInfo
      ...TokenDetails @include(if: $includeFullDetails)
    }
    sales(
      pagination: { limit: 10, offset: 0 }
      sort: { sortKey: TIME, sortDirection: DESC }
    ) {
      ...SaleInfo @include(if: $includeFullDetails)
    }
    events(
      pagination: { limit: 10, offset: 0 }
      sort: { sortKey: NONE, sortDirection: DESC }
    ) {
      ...EventInfo
    }
    markets(
      pagination: { limit: 10, offset: 0 }
      sort: { sortKey: NONE, sortDirection: DESC }
    ) {
      ...MarketInfo
      ...MarketDetails @include(if: $includeFullDetails)
    }
  }
}

query aggregateAttributes(
  $networks: [NetworkInput!]!
  $where: AggregateAttributesQueryInput!
) {
  aggregateAttributes(networks: $networks, where: $where) {
    traitType
    valueMetrics {
      value
      count
      percent
    }
  }
}

query ownersByCount(
  $networks: [NetworkInput!]!
  $pagination: PaginationInput!
  $where: CollectionAddressAndAttributesInput!
) {
  aggregateStat {
    ownersByCount(networks: $networks, pagination: $pagination, where: $where) {
      hasNextPage
      pageInfo {
        limit
        offset
      }
      nodes {
        ...OwnerCountInfo
      }
    }
  }
}

query salesVolume(
  $networks: [NetworkInput!]!
  $where: CollectionAddressAndAttributesInput!
  $timeFilter: TimeFilter
) {
  aggregateStat {
    salesVolume(where: $where, networks: $networks, timeFilter: $timeFilter) {
      ethPrice
      usdcPrice
      totalCount
    }
  }
}

query ownerCount(
  $networks: [NetworkInput!]!
  $where: CollectionAddressAndAttributesInput!
) {
  aggregateStat {
    ownerCount(where: $where, networks: $networks)
  }
}

query nftCount(
  $networks: [NetworkInput!]!
  $where: CollectionAddressOwnerAddressAttributesInput!
) {
  aggregateStat {
    nftCount(where: $where, networks: $networks)
  }
}

query floorPrice(
  $networks: [NetworkInput!]!
  $where: CollectionAddressAndAttributesInput!
) {
  aggregateStat {
    floorPrice(where: $where, networks: $networks)
  }
}

query search($pagination: SearchPaginationInput!, $query: SearchQuery!) {
  search(pagination: $pagination, query: $query) {
    hasNextPage
    pageInfo {
      limit
      offset
    }
    nodes {
      address
      description
      entityType
      name
      tokenId
    }
  }
}
