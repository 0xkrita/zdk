fragment TokenContractInfo on TokenContract {
  name
  network
  iconUrl
  description
  collectionAddress
  symbol
  chain
}

fragment FullMedia on TokenContentMedia {
  size
  url
  size
  mimeType
  mediaType
  mediaEncoding {
    preview
    original
  }
}

fragment PriceSummary on PriceAtTime {
  blockNumber
  ethPrice {
    decimal
  }
  nativePrice {
    decimal
    currency {
      address
      decimals
      name
    }
  }
  usdcPrice {
    decimal
  }
}

fragment MarketPropertiesFull on MarketProperties {
  ... on V2Auction {
    __typename
    firstBidTime
    highestBidder
    curator
    collectionAddress
    curatorFeePercentage
    duration
    estimatedExpirationTime
    auctionStatus: status
    tokenOwner
    address
    auctionId
    approved
    reservePrice {
      ...PriceSummary
    }
  }
  ... on V3Ask {
    __typename
    buyer
    finder
    findersFeeBps
    sellerFundsRecipient
    askStatus: status
    seller
    askPrice {
      ...PriceSummary
    }
  }
}

fragment MarketInfo on Market {
  collectionAddress
  marketAddress
  marketType
  price {
    ...PriceSummary
  }
  status
  networkInfo {
    chain
    network
  }
}

fragment MarketDetails on Market {
  properties {
    ...MarketPropertiesFull
  }
}

fragment TokenInfo on Token {
  minter
  tokenId
  tokenContract {
    ...TokenContractInfo
  }
  mintInfo {
    blockTimestamp
    blockNumber
    transactionHash
  }
  collectionAddress
  lastRefreshTime
  owner
  name
  description
  image {
    ...FullMedia
  }
  content {
    ...FullMedia
  }
}

fragment TokenDetails on Token {
  metadata

  tokenUrl
  tokenUrlMimeType
  # todo(iain): include transfer / market information?
}

fragment CollectionInfo on Collection {
  address
  description
  name
  symbol
  totalSupply
}

fragment CollectionDetails on Collection {
  attributes {
    traitType
    valueMetrics {
      count
      percent
      value
    }
  }
}

fragment PageInfoDefault on PageInfo {
  limit
  offset
}

query collections(
  $network: NetworkInput!
  $query: CollectionsQueryInput!
  $pagination: PaginationInput!
  $sort: CollectionSortKeySortInput!
  $isFull: Boolean!
) {
  collections(
    input: $query
    network: $network
    pagination: $pagination
    sort: $sort
  ) {
    totalCount
    pageInfo {
      limit
      offset
    }
    nodes {
      ...CollectionInfo
      ...CollectionDetails @include(if: $isFull)
    }
  }
}

# query tokens(
#   $network: NetworkInput!
#   $addresses: [String!]!
#   $pagination: PaginationInput!
#   $sort: TokenSortKeySortInput!
# ) {
#   tokens(addresses: $addresses, network: $network, pagination: $pagination, sort: $sort) {
#     totalCount
#     pageInfo {
#       limit
#       offset
#     }
#     nodes {
#       ...TokenMarketFull
#     }
#   }
# }

query tokenMarkets(
  $network: NetworkInput!
  $query: TokenMarketsQueryInput!
  $pagination: PaginationInput!
  $filter: TokenMarketsFilterInput
  $sort: TokenMarketSortKeySortInput!
  $isFull: Boolean!
) {
  # this returns all associated markets
  tokenMarkets(
    input: $query
    network: $network
    filter: $filter
    pagination: $pagination
    sort: $sort
  ) {
    nodes {
      markets {
        ...MarketInfo
        ...MarketDetails @include(if: $isFull)
      }
      token {
        ...TokenInfo
        ...TokenDetails @include(if: $isFull)
      }
      # sales {
      #   ...SaleDetails @include(if: $isFull)
      # }
    }
    pageInfo {
      ...PageInfoDefault
    }
  }
}

# query tokenMarkets(
#   $network: NetworkInput!
#   $addresses: [String!]!
#   $pagination: PaginationInput!
#   $sort: TokenSortKeySortInput!
#   $isFull: Boolean!
# ) {
#   tokens(addresses: $addresses, network: $network, pagination: $pagination, sort: $sort) {
#     totalCount
#     pageInfo {
#       ...PageInfoDefault
#     }
#     nodes {
#       ...TokenInfo
#     }
#   }
# }
