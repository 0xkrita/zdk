schema {
  query: RootQuery
}

"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

type AggregateAttribute {
  traitType: String!
  valueMetrics: [AggregateAttributeValue!]!
}

input AggregateAttributesQueryInput {
  collectionAddresses: [String!] = null
  ownerAddresses: [String!] = null
  tokens: [TokenInput!] = null
}

type AggregateAttributeValue {
  value: String!
  count: Int!
  percent: Float!
}

type AggregateStat {
  stat: IntValueFloatValue!
}

input AggregateStatQueryInput {
  collectionAddresses: [String!] = null
  ownerAddresses: [String!] = null
  attributes: [AttributeFilter!] = null
}

input AttributeFilter {
  traitType: String!
  value: String = null
}

enum Chain {
  MAINNET
}

type Collection {
  address: String!
  description: String!
  name: String
  symbol: String
  totalSupply: Int
  attributes: [CollectionAttribute!]
}

type CollectionAttribute {
  traitType: String!
  valueMetrics: [CollectionAttributeValue!]!
}

type CollectionAttributeValue {
  value: String!
  count: Int!
  percent: Float!
}

type CollectionConnection {
  nodes: [Collection!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

enum CollectionSortKey {
  NAME
  CREATED
}

input CollectionSortKeySortInput {
  sortKey: CollectionSortKey!
  sortDirection: SortDirection!
}

input CollectionsQueryInput {
  collectionAddresses: [String!]!
}

type Currency {
  name: String!
  address: String!
  decimals: Int!
}

type CurrencyAmount {
  currency: Currency!
  raw: String!
  decimal: Float!
}

"""Date (isoformat)"""
scalar Date

"""Date with time (isoformat)"""
scalar DateTime

type Event {
  transactionInfo: TransactionInfo!
  eventType: EventType!
  collectionAddress: String!
  tokenId: String!
  properties: EventProperties!
}

type EventConnection {
  nodes: [Event!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

union EventProperties = MintEvent | TransferEvent | V1MarketEvent | V2AuctionEvent | V3AskEvent

enum EventSortKey {
  CREATED
}

input EventSortKeySortInput {
  sortKey: EventSortKey!
  sortDirection: SortDirection!
}

input EventsQueryFilter {
  eventTypes: [EventType!] = null
  senderAddresses: [String!] = null
  recipientAddresses: [String!] = null
}

input EventsQueryInput {
  tokens: [TokenInput!] = null
  collectionAddresses: [String!] = null
}

enum EventType {
  MINT_EVENT
  TRANSFER_EVENT
  V1_MARKET_EVENT
  V2_AUCTION_EVENT
  V3_ASK_EVENT
}

type FloatValue {
  value: Float
  unit: String!
}

type IntValue {
  value: Int!
  unit: String!
}

union IntValueFloatValue = IntValue | FloatValue

"""
The GenericScalar scalar type represents a generic GraphQL scalar value that could be: List or Object.
"""
scalar JSONScalar

type Market {
  networkInfo: NetworkInfo!
  transactionInfo: TransactionInfo!
  status: String!
  marketAddress: String!
  collectionAddress: String!
  tokenId: String!
  marketType: MarketType!
  properties: MarketProperties!
  price: PriceAtTime
}

input MarketFilter {
  marketType: MarketType!
  statuses: [MarketStatus!] = null
  bidderAddresses: [String!] = null
}

union MarketProperties = V1Ask | V1Offer | V1BidShare | V2Auction | V3Ask

enum MarketSortKey {
  ETH_PRICE
  NATIVE_PRICE
  TIMED_SALE_ENDING
}

input MarketSortKeySortInput {
  sortKey: MarketSortKey!
  sortDirection: SortDirection!
}

input MarketsQueryFilter {
  marketFilters: [MarketFilter!] = null
  priceFilter: PriceFilter = null
}

input MarketsQueryInput {
  tokens: [TokenInput!] = null
  collectionAddresses: [String!] = null
}

enum MarketStatus {
  ACTIVE
  CANCELED
  COMPLETED
}

enum MarketType {
  V1_ASK
  V1_BID_SHARE
  V1_OFFER
  V2_AUCTION
  V3_ASK
}

type MarketWithTokenInfo {
  networkInfo: NetworkInfo!
  transactionInfo: TransactionInfo!
  status: String!
  marketAddress: String!
  collectionAddress: String!
  tokenId: String!
  marketType: MarketType!
  properties: MarketProperties!
  price: PriceAtTime
  token: Token
}

type MarketWithTokenInfoConnection {
  nodes: [MarketWithTokenInfo!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type MediaEncoding {
  large: String!
  poster: String!
  preview: String!
  thumbnail: String!
}

type MintEvent {
  tokenId: String!
  collectionAddress: String!
  originatorAddress: String!
  toAddress: String!
  fee: PriceAtTime!
}

type MintInfo {
  mintContext: TransactionInfo!
  originatorAddress: String!
  toAddress: String!
  price: PriceAtTime!
}

enum Network {
  ETHEREUM
}

type NetworkInfo {
  network: Network!
  chain: Chain!
}

input NetworkInput {
  network: Network!
  chain: Chain!
}

type PageInfo {
  limit: Int!
  offset: Int!
}

input PaginationInput {
  limit: Int!
  offset: Int!
}

type PriceAtTime {
  nativePrice: CurrencyAmount!
  blockNumber: Int!
  ethPrice: CurrencyAmount
  usdcPrice: CurrencyAmount
}

input PriceFilter {
  currencyAddress: String = null
  minimumEthPrice: String = null
  maximumEthPrice: String = null
  minimumNativePrice: String = null
  maximumNativePrice: String = null
}

type RootQuery {
  """Calculate aggregate stat"""
  aggregateStat(network: NetworkInput!, statType: StatType!, query: AggregateStatQueryInput!): AggregateStat!

  """Get aggregate attribute set"""
  aggregateAttributes(network: NetworkInput!, query: AggregateAttributesQueryInput!): [AggregateAttribute!]!

  """Get collections"""
  collections(pagination: PaginationInput!, sort: CollectionSortKeySortInput!, network: NetworkInput!, query: CollectionsQueryInput = null): CollectionConnection!

  """Get events"""
  events(network: NetworkInput!, pagination: PaginationInput!, sort: EventSortKeySortInput!, filter: EventsQueryFilter = null, query: EventsQueryInput = null): EventConnection!

  """Get sales"""
  sales(network: NetworkInput!, pagination: PaginationInput!, sort: SaleSortKeySortInput!, filter: SalesQueryFilter = null, query: SalesQueryInput = null): SaleConnection!

  """Get tokens"""
  tokens(network: NetworkInput!, pagination: PaginationInput!, sort: TokenSortKeySortInput!, filter: TokensQueryFilter = null, query: TokensQueryInput = null): TokenConnection!

  """Get token by collection address and token id"""
  token(token: TokenInput!, network: NetworkInput!): Token

  """Get token markets"""
  tokenMarkets(network: NetworkInput!, pagination: PaginationInput!, sort: TokenMarketSortKeySortInput!, query: TokenMarketsQueryInput = null, filter: TokenMarketsFilterInput = null): TokenMarketConnection!

  """Get markets"""
  markets(network: NetworkInput!, pagination: PaginationInput!, sort: MarketSortKeySortInput!, filter: MarketsQueryFilter = null, query: MarketsQueryInput = null): MarketWithTokenInfoConnection!
}

type Sale {
  saleContractAddress: String
  transactionInfo: TransactionInfo!
  buyerAddress: String!
  collectionAddress: String!
  saleType: SaleEventType!
  price: PriceAtTime!
  sellerAddress: String!
  tokenId: String!
}

type SaleConnection {
  nodes: [Sale!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

enum SaleEventType {
  FOUNDATION_SALE
  LARVA_LABS_SALE
  LOOKS_RARE_SALE
  OPENSEA_SALE
  RARIBLE_SALE
  SUPERRARE_SALE
  ZEROX_SALE
  ZORA_SALE
}

input SaleFilter {
  saleType: SaleType!
}

enum SaleSortKey {
  ETH_PRICE
  NATIVE_PRICE
  TIME
}

input SaleSortKeySortInput {
  sortKey: SaleSortKey!
  sortDirection: SortDirection!
}

input SalesQueryFilter {
  saleFilters: [SaleFilter!]!
}

input SalesQueryInput {
  collectionAddresses: [String!] = null
  sellerAddresses: [String!] = null
  buyerAddresses: [String!] = null
  tokens: [TokenInput!] = null
}

enum SaleType {
  FOUNDATION_SALE
  LARVA_LABS_SALE
  LOOKS_RARE_SALE
  OPENSEA_SINGLE_SALE
  OPENSEA_BUNDLE_SALE
  RARIBLE_SALE
  SUPERRARE_SALE
  ZEROX_SALE
  ZORA_V2_AUCTION_SALE
  ZORA_V3_ASK_SALE
}

enum SortDirection {
  ASC
  DESC
}

enum StatType {
  NFT_COUNT
  OWNER_COUNT
  SALES_VOLUME
  FLOOR_PRICE
}

type Token {
  collectionAddress: String!
  tokenId: String!
  mintInfo: MintInfo
  networkInfo: NetworkInfo!
  tokenUrl: String!
  tokenUrlMimeType: String
  content: TokenContentMedia
  image: TokenContentMedia
  owner: String
  tokenContract: TokenContract
  name: String
  description: String
  metadata: JSONScalar
  attributes: [TokenAttribute!]
  lastRefreshTime: Int
}

type TokenAttribute {
  traitType: String!
  value: String
  displayType: String
}

type TokenConnection {
  nodes: [Token!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type TokenContentMedia {
  url: String
  mimeType: String
  size: String
  mediaEncoding: MediaEncoding
}

type TokenContract {
  collectionAddress: String!
  chain: Int!
  name: String!
  symbol: String!
  totalSupply: Int
  description: String!
  network: String!
}

input TokenInput {
  address: String!
  tokenId: String!
}

type TokenMarket {
  token: Token!
  markets: [Market!]!
  events(pagination: PaginationInput!, sort: EventSortKeySortInput!, filter: EventsQueryFilter = null): EventConnection!
  sales(pagination: PaginationInput!, sort: SaleSortKeySortInput!, filter: SalesQueryFilter = null): SaleConnection!
}

type TokenMarketConnection {
  nodes: [TokenMarket!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input TokenMarketsFilterInput {
  attributeFilters: [AttributeFilter!] = null
  marketFilters: [MarketFilter!] = null
  priceFilter: PriceFilter = null
}

enum TokenMarketSortKey {
  MINTED
  TOKEN_ID
  TRANSFERRED
}

input TokenMarketSortKeySortInput {
  sortKey: TokenMarketSortKey!
  sortDirection: SortDirection!
}

input TokenMarketsQueryInput {
  collectionAddresses: [String!] = null
  ownerAddresses: [String!] = null
  tokens: [TokenInput!] = null
}

enum TokenSortKey {
  MINTED
  TOKEN_ID
  TRANSFERRED
}

input TokenSortKeySortInput {
  sortKey: TokenSortKey!
  sortDirection: SortDirection!
}

input TokensQueryFilter {
  attributeFilters: [AttributeFilter!]!
}

input TokensQueryInput {
  collectionAddresses: [String!] = null
  ownerAddresses: [String!] = null
  tokens: [TokenInput!] = null
}

type TransactionInfo {
  blockNumber: Int!
  blockTimestamp: Date!
  transactionHash: String
  logIndex: Int
}

type TransferEvent {
  fromAddress: String!
  toAddress: String!
  collectionAddress: String!
  tokenId: String!
}

type V1Ask {
  collectionAddress: String!
  tokenId: String!
  amount: PriceAtTime!
  currency: String!
  status: V1MarketEntityStatus!
}

type V1BidShare {
  tokenId: String!
  collectionAddress: String!
  previousOwner: String!
  creator: String!
  owner: String!
  status: V1MarketEntityStatus!
}

type V1MarketAskCreatedEventProperties {
  amount: String!
  price: PriceAtTime!
  currency: String!
}

type V1MarketAskRemovedEventProperties {
  amount: String!
  price: PriceAtTime!
  currency: String!
}

type V1MarketBidShareUpdatedEventProperties {
  previousOwner: String!
  creator: String!
  owner: String!
}

enum V1MarketEntityStatus {
  ACTIVE
  CANCELED
  COMPLETED
}

type V1MarketEvent {
  eventType: V1MarketEventType!
  address: String!
  collectionAddress: String!
  tokenId: String!
  properties: V1MarketEventProperties!
}

union V1MarketEventProperties = V1MarketAskCreatedEventProperties | V1MarketAskRemovedEventProperties | V1MarketOfferCreatedEventProperties | V1MarketOfferFinalizedEventProperties | V1MarketOfferRemovedEventProperties | V1MarketBidShareUpdatedEventProperties

enum V1MarketEventType {
  V1_MARKET_BID_CREATED
  V1_MARKET_BID_REMOVED
  V1_MARKET_BID_FINALIZED
  V1_MARKET_ASK_CREATED
  V1_MARKET_ASK_REMOVED
  V1_MARKET_BID_SHARE_UPDATED
}

type V1MarketOfferCreatedEventProperties {
  amount: String!
  price: PriceAtTime!
  currency: String!
  bidder: String!
  recipient: String!
  sellOnShare: String!
}

type V1MarketOfferFinalizedEventProperties {
  amount: String!
  price: PriceAtTime!
  currency: String!
  bidder: String!
  recipient: String!
  sellOnShare: String!
}

type V1MarketOfferRemovedEventProperties {
  amount: String!
  price: PriceAtTime!
  currency: String!
  bidder: String!
  recipient: String!
  sellOnShare: String!
}

type V1Offer {
  amount: PriceAtTime!
  currency: String!
  bidder: String!
  recipient: String!
  sellOnShare: String!
  tokenId: String!
  collectionAddress: String!
  status: V1MarketEntityStatus!
}

type V2Auction {
  address: String!
  tokenId: String!
  collectionAddress: String!
  auctionId: String!
  status: V2AuctionStatus!
  approved: Boolean!
  auctionCurrency: String!
  highestBidPrice: PriceAtTime
  duration: String!
  firstBidTime: DateTime
  reservePrice: PriceAtTime!
  curatorFeePercentage: Int!
  tokenOwner: String!
  highestBidder: String
  curator: String!
  estimatedExpirationTime: DateTime
  amountCuratorReceived: PriceAtTime
  amountTokenOwnerReceived: PriceAtTime
}

type V2AuctionApprovalUpdatedEventProperties {
  approved: Boolean!
}

type V2AuctionBidEventProperties {
  sender: String!
  firstBid: Boolean!
  extended: Boolean!
  value: String!
  price: PriceAtTime!
}

type V2AuctionCanceledEventProperties {
  tokenOwner: String!
}

type V2AuctionCreatedEventProperties {
  auctionCurrency: String!
  tokenOwner: String!
  curator: String!
  curatorFeePercentage: Int!
  duration: String!
  reservePrice: String!
  price: PriceAtTime!
}

type V2AuctionDurationExtendedEventProperties {
  duration: String!
}

type V2AuctionEndedEventProperties {
  tokenOwner: String!
  curator: String!
  winner: String!
  auctionCurrency: String!
  amount: String!
  curatorFee: String!
}

type V2AuctionEvent {
  eventType: V2AuctionEventType!
  address: String!
  auctionId: Int!
  collectionAddress: String!
  tokenId: String!
  properties: V2AuctionEventProperties!
}

union V2AuctionEventProperties = V2AuctionBidEventProperties | V2AuctionCreatedEventProperties | V2AuctionCanceledEventProperties | V2AuctionDurationExtendedEventProperties | V2AuctionEndedEventProperties | V2AuctionReservePriceUpdatedEventProperties | V2AuctionApprovalUpdatedEventProperties

enum V2AuctionEventType {
  V2_AUCTION_CREATED
  V2_AUCTION_CANCELED
  V2_AUCTION_RESERVE_PRICE_UPDATED
  V2_AUCTION_BID
  V2_AUCTION_DURATION_EXTENDED
  V2_AUCTION_APPROVAL_UPDATED
  V2_AUCTION_ENDED
}

type V2AuctionReservePriceUpdatedEventProperties {
  reservePrice: String!
  price: PriceAtTime!
}

enum V2AuctionStatus {
  ACTIVE
  CANCELED
  COMPLETED
}

type V3Ask {
  status: V3AskStatus!
  address: String!
  collectionAddress: String!
  tokenId: String!
  seller: String!
  sellerFundsRecipient: String!
  askCurrency: String!
  askPrice: PriceAtTime!
  findersFeeBps: Int!
  buyer: String
  finder: String
}

type V3AskCanceledEventProperties {
  seller: String!
  sellerFundsRecipient: String!
  askCurrency: String!
  askPrice: String!
  findersFeeBps: Int!
  price: PriceAtTime!
}

type V3AskCreatedEventProperties {
  seller: String!
  sellerFundsRecipient: String!
  askCurrency: String!
  askPrice: String!
  findersFeeBps: Int!
  price: PriceAtTime!
}

type V3AskEvent {
  eventType: V3AskEventType!
  address: String!
  collectionAddress: String!
  tokenId: String!
  properties: V3AskEventProperties!
}

union V3AskEventProperties = V3AskCreatedEventProperties | V3AskCanceledEventProperties | V3AskPriceUpdatedEventProperties | V3AskFilledEventProperties

enum V3AskEventType {
  V3_ASK_CREATED
  V3_ASK_CANCELED
  V3_ASK_PRICE_UPDATED
  V3_ASK_FILLED
}

type V3AskFilledEventProperties {
  seller: String!
  sellerFundsRecipient: String!
  askCurrency: String!
  askPrice: String!
  findersFeeBps: Int!
  buyer: String!
  finder: String!
  price: PriceAtTime!
}

type V3AskPriceUpdatedEventProperties {
  seller: String!
  sellerFundsRecipient: String!
  askCurrency: String!
  askPrice: String!
  findersFeeBps: Int!
  price: PriceAtTime!
}

enum V3AskStatus {
  ACTIVE
  CANCELED
  COMPLETED
}

