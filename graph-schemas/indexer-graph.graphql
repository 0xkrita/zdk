schema {
  query: RootQuery
}

"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

type AggregateAttribute {
  traitType: String!
  valueMetrics: [AggregateAttributeValue!]!
}

input AggregateAttributesQueryInput {
  collectionAddresses: [String!] = null
  ownerAddresses: [String!] = null
  tokens: [TokenInput!] = null
}

type AggregateAttributeValue {
  value: String!
  count: Int!
  percent: Float!
}

type AggregateStat {
  floorPrice(networks: [NetworkInput!]!, where: CollectionAddressAndAttributesInput!): Float
  nftCount(networks: [NetworkInput!]!, where: CollectionAddressOwnerAddressAttributesInput!): Int!
  ownerCount(networks: [NetworkInput!]!, where: CollectionAddressAndAttributesInput!): Int!
  ownersByCount(networks: [NetworkInput!]!, where: CollectionAddressAndAttributesInput!, pagination: PaginationInput!): OwnerCountConnection!
  salesVolume(networks: [NetworkInput!]!, where: CollectionAddressAndAttributesInput!, timeFilter: TimeFilter = null): Float!
}

input AttributeFilter {
  traitType: String!
  value: String = null
}

enum Chain {
  MAINNET
}

type Collection {
  address: String!
  description: String!
  name: String
  symbol: String
  totalSupply: Int
  attributes: [CollectionAttribute!]
}

input CollectionAddressAndAttributesInput {
  collectionAddresses: [String!] = null
  attributes: [AttributeFilter!] = null
}

input CollectionAddressOwnerAddressAttributesInput {
  collectionAddresses: [String!] = null
  ownerAddresses: [String!] = null
  attributes: [AttributeFilter!] = null
}

type CollectionAttribute {
  traitType: String!
  valueMetrics: [CollectionAttributeValue!]!
}

type CollectionAttributeValue {
  value: String!
  count: Int!
  percent: Float!
}

type CollectionConnection {
  nodes: [Collection!]!
  pageInfo: PageInfo!
  hasNextPage: Boolean!
}

enum CollectionSortKey {
  NONE
  NAME
  CREATED
}

input CollectionSortKeySortInput {
  sortKey: CollectionSortKey!
  sortDirection: SortDirection!
}

input CollectionsQueryInput {
  collectionAddresses: [String!]!
}

type Currency {
  name: String!
  address: String!
  decimals: Int!
}

type CurrencyAmount {
  currency: Currency!
  raw: String!
  decimal: Float!
}

"""Date (isoformat)"""
scalar Date

"""Date with time (isoformat)"""
scalar DateTime

type Event {
  transactionInfo: TransactionInfo!
  eventType: EventType!
  collectionAddress: String!
  tokenId: String!
  properties: EventProperties!
}

type EventConnection {
  nodes: [Event!]!
  pageInfo: PageInfo!
  hasNextPage: Boolean!
}

union EventProperties = MintEvent | TransferEvent | V1MarketEvent | V2AuctionEvent | V3AskEvent

enum EventSortKey {
  NONE
  CREATED
}

input EventSortKeySortInput {
  sortKey: EventSortKey!
  sortDirection: SortDirection!
}

input EventsQueryFilter {
  eventTypes: [EventType!] = null
  senderAddresses: [String!] = null
  recipientAddresses: [String!] = null
  timeFilter: TimeFilter = null
}

input EventsQueryInput {
  tokens: [TokenInput!] = null
  collectionAddresses: [String!] = null
}

enum EventType {
  MINT_EVENT
  TRANSFER_EVENT
  V1_MARKET_EVENT
  V2_AUCTION_EVENT
  V3_ASK_EVENT
}

"""
The GenericScalar scalar type represents a generic GraphQL scalar value that could be: List or Object.
"""
scalar JSONScalar

type Market {
  networkInfo: NetworkInfo!
  transactionInfo: TransactionInfo!
  status: String!
  marketAddress: String!
  collectionAddress: String!
  tokenId: String!
  marketType: MarketType!
  properties: MarketProperties!
  price: PriceAtTime
}

enum MarketCategory {
  ASK
  OFFER
  AUCTION
}

type MarketConnection {
  nodes: [Market!]!
  pageInfo: PageInfo!
  hasNextPage: Boolean!
}

union MarketProperties = V1Ask | V1Offer | V1BidShare | V2Auction | V3Ask

enum MarketSortKey {
  NONE
  ETH_PRICE
  NATIVE_PRICE
  TIMED_SALE_ENDING
}

input MarketSortKeySortInput {
  sortKey: MarketSortKey!
  sortDirection: SortDirection!
}

input MarketsQueryFilter {
  marketFilters: [MarketTypeFilter!] = null
  priceFilter: PriceFilter = null
}

input MarketsQueryInput {
  tokens: [TokenInput!] = null
  collectionAddresses: [String!] = null
}

enum MarketStatus {
  ACTIVE
  CANCELED
  COMPLETED
}

enum MarketType {
  V1_ASK
  V1_BID_SHARE
  V1_OFFER
  V2_AUCTION
  V3_ASK
}

input MarketTypeFilter {
  marketType: MarketType!
  statuses: [MarketStatus!] = null
  bidderAddresses: [String!] = null
}

type MarketWithTokenInfo {
  market: Market!
  token: Token
}

type MarketWithTokenInfoConnection {
  nodes: [MarketWithTokenInfo!]!
  pageInfo: PageInfo!
  hasNextPage: Boolean!
}

type MediaEncoding {
  large: String!
  poster: String!
  preview: String!
  thumbnail: String!
}

enum MediaType {
  IMAGE
  GIF
  VIDEO
  AUDIO
  TEXT
  HTML
}

type Mint {
  tokenId: String!
  collectionAddress: String!
  originatorAddress: String!
  toAddress: String!
  fee: PriceAtTime!
  transactionInfo: TransactionInfo!
  networkInfo: NetworkInfo!
}

type MintEvent {
  tokenId: String!
  collectionAddress: String!
  originatorAddress: String!
  toAddress: String!
  fee: PriceAtTime!
}

type MintInfo {
  mintContext: TransactionInfo!
  originatorAddress: String!
  toAddress: String!
  price: PriceAtTime!
}

enum MintSortKey {
  NONE
  TIME
  TOKEN_ID
  PRICE
}

input MintSortKeySortInput {
  sortKey: MintSortKey!
  sortDirection: SortDirection!
}

input MintsQueryFilter {
  priceFilter: PriceFilter = null
  timeFilter: TimeFilter = null
}

input MintsQueryInput {
  minterAddresses: [String!] = null
  recipientAddresses: [String!] = null
  collectionAddresses: [String!] = null
  tokens: [TokenInput!] = null
}

type MintWithTokenAndMarkets {
  mint: Mint!
  token: Token
  markets(pagination: PaginationInput!, sort: MarketSortKeySortInput!, filter: MarketsQueryFilter = null): MarketConnection!
}

type MintWithTokenAndMarketsConnection {
  nodes: [MintWithTokenAndMarkets!]!
  pageInfo: PageInfo!
  hasNextPage: Boolean!
}

enum Network {
  ETHEREUM
}

type NetworkInfo {
  network: Network!
  chain: Chain!
}

input NetworkInput {
  network: Network! = ETHEREUM
  chain: Chain! = MAINNET
}

type OwnerCount {
  owner: String!
  count: Int!
}

type OwnerCountConnection {
  nodes: [OwnerCount!]!
  pageInfo: PageInfo!
  hasNextPage: Boolean!
}

type PageInfo {
  limit: Int!
  offset: Int!
}

input PaginationInput {
  limit: Int! = 10
  offset: Int! = 0
}

type PriceAtTime {
  nativePrice: CurrencyAmount!
  blockNumber: Int!
  ethPrice: CurrencyAmount
  usdcPrice: CurrencyAmount
}

input PriceFilter {
  currencyAddress: String = null
  minimumEthPrice: String = null
  maximumEthPrice: String = null
  minimumNativePrice: String = null
  maximumNativePrice: String = null
}

type RootQuery {
  """Calculate aggregate stat"""
  aggregateStat: AggregateStat!

  """Get aggregate attribute set"""
  aggregateAttributes(networks: [NetworkInput!]!, where: AggregateAttributesQueryInput!): [AggregateAttribute!]!

  """Get collections"""
  collections(pagination: PaginationInput!, sort: CollectionSortKeySortInput!, networks: [NetworkInput!]!, where: CollectionsQueryInput = null): CollectionConnection!

  """Get events"""
  events(networks: [NetworkInput!]!, pagination: PaginationInput!, sort: EventSortKeySortInput!, filter: EventsQueryFilter = null, where: EventsQueryInput = null): EventConnection!

  """Get markets"""
  markets(networks: [NetworkInput!]!, pagination: PaginationInput!, sort: MarketSortKeySortInput!, filter: MarketsQueryFilter = null, where: MarketsQueryInput = null): MarketWithTokenInfoConnection!

  """Get mints"""
  mints(networks: [NetworkInput!]!, pagination: PaginationInput!, sort: MintSortKeySortInput!, filter: MintsQueryFilter = null, where: MintsQueryInput = null): MintWithTokenAndMarketsConnection!

  """Get sales"""
  sales(networks: [NetworkInput!]!, pagination: PaginationInput!, sort: SaleSortKeySortInput!, filter: SalesQueryFilter = null, where: SalesQueryInput = null): SaleWithTokenInfoConnection!

  """Get tokens"""
  tokens(networks: [NetworkInput!]!, pagination: PaginationInput!, sort: TokenSortInput!, where: TokensQueryInput = null, filter: TokensQueryFilter = null): TokenWithMarketsConnection!

  """Get token by collection address and token id"""
  token(token: TokenInput!, network: NetworkInput!): Token
}

type Sale {
  saleContractAddress: String
  transactionInfo: TransactionInfo!
  networkInfo: NetworkInfo!
  buyerAddress: String!
  collectionAddress: String!
  saleType: SaleType!
  price: PriceAtTime!
  sellerAddress: String!
  tokenId: String!
}

type SaleConnection {
  nodes: [Sale!]!
  pageInfo: PageInfo!
  hasNextPage: Boolean!
}

enum SaleSortKey {
  NONE
  ETH_PRICE
  NATIVE_PRICE
  TIME
}

input SaleSortKeySortInput {
  sortKey: SaleSortKey!
  sortDirection: SortDirection!
}

input SalesQueryFilter {
  saleTypes: [SaleType!] = null
  priceFilter: PriceFilter = null
  timeFilter: TimeFilter = null
}

input SalesQueryInput {
  collectionAddresses: [String!] = null
  sellerAddresses: [String!] = null
  buyerAddresses: [String!] = null
  tokens: [TokenInput!] = null
}

enum SaleType {
  FOUNDATION_SALE
  LARVA_LABS_SALE
  LOOKS_RARE_SALE
  OPENSEA_SINGLE_SALE
  OPENSEA_BUNDLE_SALE
  RARIBLE_SALE
  SUPERRARE_SALE
  ZEROX_SALE
  ZORA_V2_AUCTION_SALE
  ZORA_V3_ASK_SALE
}

type SaleWithTokenInfo {
  sale: Sale!
  token: Token
}

type SaleWithTokenInfoConnection {
  nodes: [SaleWithTokenInfo!]!
  pageInfo: PageInfo!
  hasNextPage: Boolean!
}

enum SortDirection {
  ASC
  DESC
}

input TimeFilter {
  startDate: String = null
  endDate: String = null
  lookbackHours: Int = null
}

type Token {
  collectionAddress: String!
  tokenId: String!
  mintInfo: MintInfo
  networkInfo: NetworkInfo!
  tokenUrl: String
  tokenUrlMimeType: String
  content: TokenContentMedia
  image: TokenContentMedia
  owner: String
  tokenContract: TokenContract
  name: String
  description: String
  metadata: JSONScalar
  attributes: [TokenAttribute!]
  lastRefreshTime: Int
}

type TokenAttribute {
  traitType: String!
  value: String
  displayType: String
}

type TokenContentMedia {
  url: String
  mimeType: String
  size: String
  mediaEncoding: MediaEncoding
}

type TokenContract {
  collectionAddress: String!
  chain: Int!
  name: String
  symbol: String
  totalSupply: Int
  description: String
  network: String!
}

input TokenInput {
  address: String!
  tokenId: String!
}

input TokenSortInput {
  sortKey: TokenSortKey!
  sortDirection: SortDirection!
  sortAxis: MarketCategory = null
}

enum TokenSortKey {
  NONE
  MINTED
  TOKEN_ID
  TRANSFERRED
  ETH_PRICE
  NATIVE_PRICE
  TIMED_SALE_ENDING
}

input TokensQueryFilter {
  attributeFilters: [AttributeFilter!] = null
  mediaType: MediaType = null
  marketFilters: [MarketTypeFilter!] = null
  priceFilter: PriceFilter = null
}

input TokensQueryInput {
  collectionAddresses: [String!] = null
  ownerAddresses: [String!] = null
  tokens: [TokenInput!] = null
}

type TokenWithMarkets {
  token: Token!
  markets: [Market!]!
  events(pagination: PaginationInput!, sort: EventSortKeySortInput!, filter: EventsQueryFilter = null): EventConnection!
  sales(pagination: PaginationInput!, sort: SaleSortKeySortInput!, filter: SalesQueryFilter = null): SaleConnection!
}

type TokenWithMarketsConnection {
  nodes: [TokenWithMarkets!]!
  pageInfo: PageInfo!
  hasNextPage: Boolean!
}

type TransactionInfo {
  blockNumber: Int!
  blockTimestamp: Date!
  transactionHash: String
  logIndex: Int
}

type TransferEvent {
  fromAddress: String!
  toAddress: String!
  collectionAddress: String!
  tokenId: String!
}

type V1Ask {
  collectionAddress: String!
  tokenId: String!
  amount: PriceAtTime!
  currency: String!
  status: V1MarketEntityStatus!
}

type V1BidShare {
  tokenId: String!
  collectionAddress: String!
  previousOwner: String!
  creator: String!
  owner: String!
  status: V1MarketEntityStatus!
}

type V1MarketAskCreatedEventProperties {
  amount: String!
  price: PriceAtTime!
  currency: String!
}

type V1MarketAskRemovedEventProperties {
  amount: String!
  price: PriceAtTime!
  currency: String!
}

type V1MarketBidShareUpdatedEventProperties {
  previousOwner: String!
  creator: String!
  owner: String!
}

enum V1MarketEntityStatus {
  ACTIVE
  CANCELED
  COMPLETED
}

type V1MarketEvent {
  eventType: V1MarketEventType!
  address: String!
  collectionAddress: String!
  tokenId: String!
  properties: V1MarketEventProperties!
}

union V1MarketEventProperties = V1MarketAskCreatedEventProperties | V1MarketAskRemovedEventProperties | V1MarketOfferCreatedEventProperties | V1MarketOfferFinalizedEventProperties | V1MarketOfferRemovedEventProperties | V1MarketBidShareUpdatedEventProperties

enum V1MarketEventType {
  V1_MARKET_BID_CREATED
  V1_MARKET_BID_REMOVED
  V1_MARKET_BID_FINALIZED
  V1_MARKET_ASK_CREATED
  V1_MARKET_ASK_REMOVED
  V1_MARKET_BID_SHARE_UPDATED
}

type V1MarketOfferCreatedEventProperties {
  amount: String!
  price: PriceAtTime!
  currency: String!
  bidder: String!
  recipient: String!
  sellOnShare: String!
}

type V1MarketOfferFinalizedEventProperties {
  amount: String!
  price: PriceAtTime!
  currency: String!
  bidder: String!
  recipient: String!
  sellOnShare: String!
}

type V1MarketOfferRemovedEventProperties {
  amount: String!
  price: PriceAtTime!
  currency: String!
  bidder: String!
  recipient: String!
  sellOnShare: String!
}

type V1Offer {
  amount: PriceAtTime!
  currency: String!
  bidder: String!
  recipient: String!
  sellOnShare: String!
  tokenId: String!
  collectionAddress: String!
  status: V1MarketEntityStatus!
}

type V2Auction {
  address: String!
  tokenId: String!
  collectionAddress: String!
  auctionId: String!
  status: V2AuctionStatus!
  approved: Boolean!
  auctionCurrency: String!
  highestBidPrice: PriceAtTime
  duration: String!
  firstBidTime: DateTime
  reservePrice: PriceAtTime!
  curatorFeePercentage: Int!
  tokenOwner: String!
  highestBidder: String
  curator: String!
  estimatedExpirationTime: DateTime
  amountCuratorReceived: PriceAtTime
  amountTokenOwnerReceived: PriceAtTime
}

type V2AuctionApprovalUpdatedEventProperties {
  approved: Boolean!
}

type V2AuctionBidEventProperties {
  sender: String!
  firstBid: Boolean!
  extended: Boolean!
  value: String!
  price: PriceAtTime!
}

type V2AuctionCanceledEventProperties {
  tokenOwner: String!
}

type V2AuctionCreatedEventProperties {
  auctionCurrency: String!
  tokenOwner: String!
  curator: String!
  curatorFeePercentage: Int!
  duration: String!
  reservePrice: String!
  price: PriceAtTime!
}

type V2AuctionDurationExtendedEventProperties {
  duration: String!
}

type V2AuctionEndedEventProperties {
  tokenOwner: String!
  curator: String!
  winner: String!
  auctionCurrency: String!
  amount: String!
  curatorFee: String!
}

type V2AuctionEvent {
  eventType: V2AuctionEventType!
  address: String!
  auctionId: Int!
  collectionAddress: String!
  tokenId: String!
  properties: V2AuctionEventProperties!
}

union V2AuctionEventProperties = V2AuctionBidEventProperties | V2AuctionCreatedEventProperties | V2AuctionCanceledEventProperties | V2AuctionDurationExtendedEventProperties | V2AuctionEndedEventProperties | V2AuctionReservePriceUpdatedEventProperties | V2AuctionApprovalUpdatedEventProperties

enum V2AuctionEventType {
  V2_AUCTION_CREATED
  V2_AUCTION_CANCELED
  V2_AUCTION_RESERVE_PRICE_UPDATED
  V2_AUCTION_BID
  V2_AUCTION_DURATION_EXTENDED
  V2_AUCTION_APPROVAL_UPDATED
  V2_AUCTION_ENDED
}

type V2AuctionReservePriceUpdatedEventProperties {
  reservePrice: String!
  price: PriceAtTime!
}

enum V2AuctionStatus {
  ACTIVE
  CANCELED
  COMPLETED
}

type V3Ask {
  status: V3AskStatus!
  address: String!
  collectionAddress: String!
  tokenId: String!
  seller: String!
  sellerFundsRecipient: String!
  askCurrency: String!
  askPrice: PriceAtTime!
  findersFeeBps: Int!
  buyer: String
  finder: String
}

type V3AskCanceledEventProperties {
  seller: String!
  sellerFundsRecipient: String!
  askCurrency: String!
  askPrice: String!
  findersFeeBps: Int!
  price: PriceAtTime!
}

type V3AskCreatedEventProperties {
  seller: String!
  sellerFundsRecipient: String!
  askCurrency: String!
  askPrice: String!
  findersFeeBps: Int!
  price: PriceAtTime!
}

type V3AskEvent {
  eventType: V3AskEventType!
  address: String!
  collectionAddress: String!
  tokenId: String!
  properties: V3AskEventProperties!
}

union V3AskEventProperties = V3AskCreatedEventProperties | V3AskCanceledEventProperties | V3AskPriceUpdatedEventProperties | V3AskFilledEventProperties

enum V3AskEventType {
  V3_ASK_CREATED
  V3_ASK_CANCELED
  V3_ASK_PRICE_UPDATED
  V3_ASK_FILLED
}

type V3AskFilledEventProperties {
  seller: String!
  sellerFundsRecipient: String!
  askCurrency: String!
  askPrice: String!
  findersFeeBps: Int!
  buyer: String!
  finder: String!
  price: PriceAtTime!
}

type V3AskPriceUpdatedEventProperties {
  seller: String!
  sellerFundsRecipient: String!
  askCurrency: String!
  askPrice: String!
  findersFeeBps: Int!
  price: PriceAtTime!
}

enum V3AskStatus {
  ACTIVE
  CANCELED
  COMPLETED
}

